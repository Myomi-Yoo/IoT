exam <- read.csv("csv_exam.csv")
exam
#전체 레코드의 맨 위에서부터 정의한 갯수만큼 가져오기
head(exam,n = 5)
tail(exam, 5)
#실제 뷰어로 보기
View(exam)
data("mpg")
data("mpg")
mpg <- as.data.frame(data("mpg"))
d <- data("mpg")
d
nrow(exam)
#
ncol(exam)
dim(exam)
#타입확인
class(exam)
#구조확인
str(exam)
#데이터에 대한 요약정보
summary(exam)
exam
#컴럼의 이름을 변경 - dplyr
install.packages("dplyr")
library("dplyr")
#rename(data, 변경할 컬럼명=기존컬럼명)
exam <- rename(exam, eng=english)
exam
install.packages("beepr")
library("beepr")
beep()
library("beepr")
beep()
for(i in 1:10){
beep(sound = i)
Sys.sleep(1)#1초동안 프로세스를 동작시키지 않겠다는 의미
}
.libPaths()
install.packages("beepr")
install.packages("beepr")
library("beepr")
beep()
for(i in 1:10){
beep(sound = i)
Sys.sleep(1)#1초동안 프로세스를 동작시키지 않겠다는 의미
}
install.packages("data.table")
library("data.table")
df <- data.frame(mydata1=1:5,
mydata2=letters[1:5],
mydata3=c("이민호","android","@한글%$@","test","한글"))
df
####파일write####
write.csv(df,"encoding_test.csv",row.names = FALSE)
write.csv(df,"encoding_test_euckr.csv",row.names = FALSE
,fileEncoding = "euc-kr" )
write.csv(df,"encoding_test_cp949.csv",row.names = FALSE
,fileEncoding = "cp949" )
write.csv(df,"encoding_test_utf8.csv",row.names = FALSE
,fileEncoding = "utf8" )
####깨진파일 처리하기####
read.csv("encoding_test_utf8.csv")
readLines("encoding_test_utf8.csv")
readLines("encoding_test_utf8.csv",encoding = "UTF-8")
#data.table - dataframe보다 강력
dftable <- fread("encoding_test_utf8.csv")
head(dftable)
#인코딩함수
Encoding(dftable$mydata3) = "UTF-8"
head(dftable)
install.packages("ggplot2")
library("ggplot2")
mydata <- c("java","spring","bigdata","android")
qplot(mydata)
qplot(data = mpg,x = hwy)
qplot(data = mpg,x = hwy)
install.packages("ggplot2")
library("ggplot2")
mydata <- c("java","spring","bigdata","android")
qplot(mydata)
qplot(data = mpg,x = hwy)
mpg
mydata <- c("java","spring","bigdata","android")
qplot(mydata)
qplot(data = mpg,x = hwy)
qplot(data = mpg,x = hwy,y = drv)
install.packages("ggplot2")
install.packages("ggplot2")
library("ggplot2")
qplot(data = mpg,x = hwy)
View(mpg)
remove.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
library("ggplot2")
mpg <- as.data.frame(mpg)
nrow(mpg)
View(mpg)
View(mpg)
View(mpg)
View(mpg)
View(mpg)
View(mpg)
mpg <- as.data.frame(mpg)
nrow(mpg)
remove.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
library("ggplot2")
library("ggplot2")
mpg <- as.data.frame(mpg)
nrow(mpg)
View(mpg)
View(mpg)
View(mpg)
remove.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
library("ggplot2")
qplot(data = mpg,x = hwy)
qplot(data = mpg,x = hwy,y = drv)
qplot(data = mpg,x = drv,y = hwy,geom = "line")
qplot(data = mpg,x = drv,y = hwy,geom = "boxplot")
qplot(data = mpg,x = drv,y = hwy,geom = "line")
qplot(data = mpg,x = drv,y = hwy,geom = "boxplot")
mpg <- as.data.frame(mpg)
qplot(data = mpg,x = drv,y = hwy,geom = "boxplot",colour=drv)
nrow(mpg)
####외부데이터 읽어오기####
####csv파일읽기####
#readLines을 이용하면 데이터가 커도 어떤 구성인지 확인하기 편하다
dfimport <-  readLines("01_csv.csv",n = 3)
dfimport
?data.frame
#csv파일이므로 ,로 구분이 되어 있지만 사용자가 원하는 구분자를 적용해서 작성한 문자열인 경우
#01_csv.csv읽은 내용을 가공해서 데이터프레임을 작성
dfcsv <- data.frame(num=1:3,
mydata = dfimport,
stringsAsFactors = FALSE)
dfcsv
dfcsv$mydata #컬럼안의 문자열이 ,가 추가
str(dfcsv)
#,로 분리는 되지만 list도 결과가 리턴되어 불편==============
strsplit(dfcsv$mydata,split = ",")[[1]]
strsplit(dfcsv$mydata,split = ",")[[2]]
#하나의 컬럼안에 구분자로 텍스트가 구성된 경우 분리
install.packages("splitstackshape")
library("splitstackshape")
dfcsv2 <- cSplit(indt = dfcsv,
splitCols = "mydata",
sep = ",")
dfcsv2
class(dfcsv2)
dfcsv
dfcsv2
class(dfcsv2)
#타입 변경
# as의 함수들을 이용해서 변경
# as는 ~~~가 아닌 것을 ~~~로 변경한다는의미 - data.table과 data.frame의 속성을 가지고 있는 dfcsv2를 dataframe으로 변경
dfcsv2 <- as.data.frame(dfcsv2)
#타입 변경
# as의 함수들을 이용해서 변경
# as는 ~~~가 아닌 것을 ~~~로 변경한다는의미 - data.table과 data.frame의 속성을 가지고 있는 dfcsv2를 dataframe으로 변경
dfcsv2 <- as.data.frame(dfcsv2)
class(dfcsv2) #타입을 확인
class(dfcsv2$num)
class(dfcsv2$mydata_1)
dfcsv2
class(dfcsv2) #타입을 확인
str(dfcsv2)
class(dfcsv2$mydata_1)
class(dfcsv2$mydata_2)
class(dfcsv2$mydata_3)
class(dfcsv2$mydata_4)
class(dfcsv2$mydata_5)
class("dd")
str(dfcsv2) #전체 데이터의 구조를 확인
#변환한 데이터들의 타입이 Factor
#Factor는 순서와 명목형
#1,2,3,.....의 값이 어떤 순서를 의미하는 경우 : 컬럼의 데이터가 순서형
#class컬럼 1,2,3,4...:순서를 의미하지 않고 1반, 2반, 3반....
#순서가 적용되도록 정의된 Factor타입을 char로 변경
#1번 컬럼을 뺀 나머지 컬럼의 타입을 char로 변환
for(i in 2:ncol(dfcsv2) ){
dfcsv2[,i] = as.character(dfcsv2[,i])
}
str(dfcsv2)
####tsv 파일 읽기####
#tab으로 구분된 파일(\t)
df3 <- read.delim("02_tsv.txt" ,sep = "\t")  #java의 Stringtokenizer 기능
head(df3)       # 기본 6줄이 읽힌다.
####xml 파일 읽기####
install.packages("XML")
library("XML")
?xmlTreeParse
dfxml <- xmlTreeParse("03_xml.xml")
dfxml
# root element와 하위엘리먼트만 추출
dfxml <- xmlRoot(dfxml)
dfxml
library("XML")
dfxml <- xmlTreeParse("03_xml.xml")
dfxml
#xml에 있는 모든 태그의 name과 value를 추출
#xxxApply함수는 for문 대신 사용할 수 있는 함수
dfxml <- xmlSApply(dfxml,function(x){
xmlSApply(x,xmlValue)
})
dfxml
dfxml <- data.frame(t(dfxml),row.names = NULL)
dfxml
####xlsx 파일 읽기####
install.packages("readxl")
library("readxl")
dfxlsx <- read_xlsx("07_xlsx.xlsx")
dfxlsx # tibble => data.frame과 비슷한 다른 종류의 라이브러리
a <- sample(1:10)
a
a <- sample(1:10,size = 5)
a
a <- sample(1:10,size = 5)
a
a <- sample(1:10,size = 5)
a
a <- sample(1:10,size = 5)
a <- sample(1:10,size = 5,replace = FALSE)
a
a <- sample(1:10,size = 3,replace = FALSE)
a
a <- sample(1:10,size = 3,replace = FALSE)
a
a <- sample(1:10,size = 3,replace = FALSE)
a
a <- sample(1:10,size = 5,replace = FALSE)
a
a <- sample(1:10,size = 5,replace = FALSE)
a
a <- sample(1:10,size = 5,replace = FALSE)
a
a <- sample(1:10,size = 5,replace = FALSE)
a
a <- sample(1:10,size = 5,replace = TRUE)
a
a <- sample(1:10,size = 5,replace = TRUE)
a
a <- sample(1:10,size = 5,replace = TRUE)
a
a <- sample(1:10,size = 5,replace = TRUE)
a
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)
a <- sample(1:10,size = 5,replace = FALSE)
a
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
a
a
a
a <- sample(1:10,size = 5,replace = FALSE)
a
a
a
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
?xmlTreeParse
?xmlTreeParse
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(121)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
set.seed(1222)#1222는 key
a <- sample(1:10,size = 5,replace = FALSE)
a
#if문의 역할을 하는 함수 - ifesle
set.seed(1222)
ifdf <- data.frame(mynum=1:6,
myval=sample(c("spring","bigdata","android"),
size = 6,
replace = TRUE))
ifdf
#if문의 역할을 하는 함수 - ifesle
set.seed(1221)
ifdf <- data.frame(mynum=1:6,
myval=sample(c("spring","bigdata","android"),
size = 6,
replace = TRUE))
ifdf
#if문의 역할을 하는 함수 - ifesle
set.seed(1221)
ifdf <- data.frame(mynum=1:6,
myval=sample(c("spring","bigdata"),
size = 6,
replace = TRUE))
ifdf
#myval의 값이 spring이면 프로젝트완료, bigdata이면 할꺼야
for(i in 1:nrow(ifdf)){
if(ifdf[i,"myval"]=="spring"){
ifdf[i,"info"] <- "프로젝트완료"
}else{
ifdf[i,"info"] <- "할꺼야"
}
}
ifdf
#함수를 이용해서 - info2
ifdf[,"info2"] <- ifelse(test = ifdf$myval=="spring",
yes = "쉽다",
no = "할꺼다")
ifdf
set.seed(1221)
ifdf <- data.frame(mynum=1:6,
myval=sample(c("spring","bigdata"),
size = 6,
replace = TRUE))
ifdf
#myval의 값이 spring이면 프로젝트완료, bigdata이면 할꺼야
for(i in 1:nrow(ifdf)){
if(ifdf[i,"myval"]=="spring"){
ifdf[i,"info"] <- "프로젝트완료"
}else{
ifdf[i,"info"] <- "할꺼야"
}
}
ifdf
#함수를 이용해서 - info2
ifdf[,"info2"] <- ifelse(test = ifdf$myval=="spring",
yes = "쉽다",
no = "할꺼다")
ifdf
set.seed(1221)
ifdf <- data.frame(mynum=1:6,
myval=sample(c("spring","bigdata","android"),
size = 6,
replace = TRUE))
ifdf
#myval의 값이 spring이면 프로젝트완료, bigdata이면 할꺼야
for(i in 1:nrow(ifdf)){
if(ifdf[i,"myval"]=="spring"){
ifdf[i,"info"] <- "프로젝트완료"
}else{
ifdf[i,"info"] <- "할꺼야"
}
}
ifdf
#함수를 이용해서 - info2
ifdf[,"info2"] <- ifelse(test = ifdf$myval=="spring",
yes = "쉽다",
no = "할꺼다")
ifdf
#조건이 2개 이상인 경우 처리
ifdf[,"info3"] <- ifelse(test = ifdf$myval=="spring",
yes = "쉽다",
no = ifelse(test = ifdf$myval=="bigdata",
yes = "머신셋팅",
no = "device셋팅완료"))
ifdf
ifdf[,"info4"] <- "쉽다"
ifdf
#### step2. mpg의 정보를 출력 ####
# 행 갯수, 열의 갯수, 위에서 10개, 끝에서 10개 출력
nrow(mpg)
ncol(mpg)
head(mpg, 10)
tail(mpg, 10)
dim(mpg)
#### step3. mpg의 컬럼명을 변경 ####
# cty => city, hwy => highway
library("dplyr")
mpg <- rename(mpg, city=cty)
mpg <- rename(mpg, highway=hwy)
mpg
#### step4. 파생변수 생성하기 ####
# total컬럼을 추가 => cty와 hwy의 합
# avg컬럼을 추가 => cty와 hwy의 평균
mpg$total <- mpg$city+mpg$highway
mpg$avg <- mpg$total/2
mpg
#### step5. 생성된 total을 가지고 요약정보 확인 ####
summary(mpg$total)
#### step6. info컬럼 추가 ####
# total값을 이용해서 평가 - 30이상이면 pass, fail
mpg[,"info"] <- ifelse(test = mpg$total>=30,
yes = "pass",
no = "fail")
mpg
#### step7. grade컬럼 추가 ####
# total값을 이용해서 평가 - 40이상이면 A, 35이상이면 B, 30이상이면 C, 나머지 D
mpg[,"info"] <- ifelse(test = mpg$total>=40,
yes = "A",
no = ifelse(test = mpg$total>=35,
yes = "B",
no = ifelse(test = mpg$total>=30,
yes = "C",
no = "D")))
#### step6. info컬럼 추가 ####
# total값을 이용해서 평가 - 30이상이면 pass, fail
mpg[,"info"] <- ifelse(test = mpg$total>=30,
yes = "pass",
no = "fail")
mpg
#### step7. grade컬럼 추가 ####
# total값을 이용해서 평가 - 40이상이면 A, 35이상이면 B, 30이상이면 C, 나머지 D
mpg[,"info2"] <- ifelse(test = mpg$total>=40,
yes = "A",
no = ifelse(test = mpg$total>=35,
yes = "B",
no = ifelse(test = mpg$total>=30,
yes = "C",
no = "D")))
mpg
#rename(data, 변경할 컬럼명=기존컬럼명)
exam <- rename(exam, eng=english)
exam
exam <- read.csv("csv_exam.csv")
#rename(data, 변경할 컬럼명=기존컬럼명)
exam <- rename(exam, eng=english)
exam
table(exam$eng)
qplot(exam$eng)
